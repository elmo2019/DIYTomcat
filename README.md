# DIYTomcat 开发日志
  本开发日志用于记录项目开发历程，包括如何实现业务，如何解决难点，为什么要对之前的代码进行重构。注重业务逻辑方面，不包括方法和jar包工具的应用。
 
 ## Before 4.25
 ### 项目雏形
    1. 简单的服务器
       基于网络编程，监听端口，能对发送到端口的信息接收简单处理（只接收1024字节长度），能够返回简单的http响应。
    2.简单的游览器
       给定访问地址，能够访问它，并取回解析服务器的http响应。该浏览器并不简单，之后会专门开一节来解析浏览器代码。
    3.测试
       每完成一个业务，实现一个功能我们都要去测试是否正常，会不会影响到之前的业务功能，使用自动测试能更高效。
       使用MiniBrowser的解析游览器的解析http响应功能，判断期盼的内容时候和实际的内容一致。
       * 本功能基于Junit技术
       
  ### 增强服务器接收和返回功能
      基于服务器雏形，面对复杂的业务逐渐增强功能
      1. 包装 request & response 对象
         - 服务器接到请求并不可能只有1024字节，包装resquest 对象，能够对读取任意字节长度的信息。
         - 返回的内容应该根据请求的内容来选择。包装 response 对象，能够返回指定的（业务判断之后选取的内容）的内容。
           response 对象只负责写入内容，真正的返回步骤有 handle方法来处理
         * 本功能包含了复杂的流知识
      2. 处理多请求功能
         - 服务器往往会同时接到多个请求，运用线程池技术，为每一个新的请求都开辟线程去处理
           * 本功能包含复杂的线程，线程池知识
         - 客户端可能会请求指定的文本文件，解析请求的内容，判断是哪一个文件
      3. 日志功能
         * 本功能基于 log4j技术
  
 ### 多应用技术配置
     增加功能，实现本项目能像tomcat 一样实现多应用功能
     1. 多应用实现
        - 扫描Webapps目录下的文件，将多应用的Context 的 path-docBase的映射用HashMap保存起来
        - 配置 serve.xml 文件，解析xml文件实现动态配置多应用
     2. 多组件实现
        除了context 组件外，配置丰富组件。
        由 context -> host -> engine -> Service -> Sever
        以上各组件之间是父子关系，其中 context 和 host 在同一父组件可以有多个，但是host一定有一个
        自底向上逐层包装，新建各组件类组层解析。
        * 本项目放弃了tomcat中原本的 Digester 模式

### 请求分析
- 在之前的 response 业务中，只针对判断了需要返回那个文件。其实，正式情况下会发生文件没有的请求错误(400),服务器处理错误(500)，还有未指定位置就返回欢迎页面。
    
## 4.26
   - 在此之前，通过硬返回的方式直接告诉游览器（客户端）返回文件类型是 txt/html 类型，但是实际情况下我们可能会返回各种各样的文件类型。在webXML文件中添加文件类型映射。再返回文件时，获取文件类型。用Map来存储映射。
   - 因为要传输不止html文件，要传二进制字节流的形式，既要改造文件读取方式，不再是读取文件中的字符串，直接读取文件的二进制字节流。
   - 在Apache Tomcat 里，支持多端口，在server.xml 文件里配置多端口，向其他组件一样新建类，解析获取Connector类，因为多端口，每个端口都要独立解决请求和返回问题。将之前的Server类代码迁移到Connector类中
   - 此时在 Connect类中既要监听端口，又要处理接受和返回。将业务拆封，把处理http请求的业务放在httpProcessor中
   
## 逐步实现Servlet容器功能
### 简单的servlet响应
- 为了能够能将response和request对象传入svelte类中，必须使他们继承HttpServletResponse 接口，直接继承又显得冗余，所以创建basedrequest & basedresponse
### 配置servlet
- 之前是直接路径访问，通过实现配置文件和解析配置文件功能，实现servlet的配置
- 配置文件中通过4个map保存servlet之间雷名，绝对路径，相对路径名的映射
### 拆分处理类
    在此之前，主要实现了处理对静态资源的请求，为了处理servlet请求，必须将业务拆分
- DefaultServlet, 用来处理静态资源。
  提供 service 方法，根据 请求的uri 获取 ServletClassName ，然后实例化，接着调用其 service 方法。因为目标 servlet 实现了 HttpServlet ,所以一定提供了 service 方法。 这个 service 方法实会根据 request 的 Method ，访问对应的 doGet 或者 doPost。 单例模式
- InvokerServelet, 用来处理Servlet。实际上就是怕HttpProcessor 里面的处理代码拆分出来，新创建状态码属性，两种处理都能使用，设置状态码。
- JspServlet 处理jsp文件

### 实现公共类加载器
- 为什么要自己写tomcat自己的类加载器？Servlet涉及到动态加载，在不同的Web应用下可能会存在相同类名的类，通过重写自己的类加载器，保证不会出错。
- 分为公共类加载器和应用类加载器。

### 热加载功能完成
- 热加载功能是，当部署的web项目内容发生变化时，可以及时检测，不用重启便能重新加载
- 原理：使用监听器监听文件变化（.class .jar .xml） ，如果文件发生变化，对context类进行重新配置，并且刷新 host
- 新增监听器类，为context增加监听器属性和重载属性，设置同步机制
 
        
        
        
        
        
        
        
        
        
  
